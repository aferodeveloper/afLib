/**
   Copyright 2015-2018 Afero, Inc.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

/*
   afBlink is a simple "hello world" type application that blinks the LED
   of a Modulo development board. This application shows the bare minimum 
   code required to communicate with the Afero Cloud. More robust examples of
   how to do everything you can do with this library are available in the
   developer documentation and other example apps.

   TERMS: In the comments of this code, we'll use the words "Modulo" and "ASR"
          a lot, and sometimes it may seem they're interchangeable, though they
          are not. The ASR is the Afero Secure Radio module that is the heart
          of the communication between the MCU and the Afero Cloud. "Modulo"
          is the name of the physical Afero Development Board that you can use
          to prototype your hardware and software. The Modulo development board
          includes an ASR, of course, along with some other things to make 
          development easier - a voltage regulator, a USB-Serial interface, and 
          an LED and button connected to the ASR's GPIO pins for simple interaction.
          We'll try to be as consistent as possible to say "Modulo" when we are
          talking about something specific to the Modulo hardware (LED, button,
          and physical pin connections to the MCU) and say "ASR" all other times
          when referring to the communication between the MCU and the Afero Cloud.
*/


#include <SPI.h>

#include "af_lib.h"
#include "arduino_spi.h"
#include "arduino_uart.h"
#include "af_module_commands.h"
#include "af_module_states.h"
#include "arduino_transport.h"

// Include the constants required to access attribute ids from your profile.
// These defines are automatically generated by the Afero Profile Editor
//#include "profile/afBlink_Modulo-1_SPI/device-description.h"           // For Modulo-1 SPI
//#include "profile/afBlink_Modulo-1_UART/device-description.h"          // For Modulo-1 UART
//#include "profile/afBlink_Modulo-1B_SPI/device-description.h"          // For Modulo-1B SPI
//#include "profile/afBlink_Modulo-1B_UART/device-description.h"         // For Modulo-1B UART
#include "profile/afBlink_Modulo-2_SPI/device-description.h"           // For Modulo-2 SPI
//#include "profile/afBlink_Modulo-2_UART/device-description.h"          // For Modulo-2 UART


// Select the MCU interface to be used. This define must also match
// the physical hardware pins connecting the MCU and Modulo, and also
// the MCU Configuration section of the profile loaded on the Modulo
//     (in the Afero Profile Editor app "Attributes" menu, interface and UART speed)
#define ARDUINO_USE_SPI                   1
//#define ARDUINO_USE_UART                  1

// For Modulo-1 UART speed is fixed at 9600
// For Modulo-2 the UART_BAUD_RATE here must match the UART speed set in Profile Editor
#define UART_BAUD_RATE            9600

// Automatically detect MCU board type
#if defined(ARDUINO_AVR_UNO)          // Arduino Uno using an Afero Plinto shield
#undef RESET                            // On Plinto the ASR RESET line is tied to the Uno RESET line
// Only needed for SPI
#define INT_PIN                   2     // Modulo sends an interrupt on this pin to initiate communication
#define CS_PIN                    10    // Standard SPI chip select line
// Only needed for UART
// For Uno and UART you will need to connect the UART pins on the Modulo board to these
// pins on the Plinto board
#define RX_PIN                    7     // Connect to Modulo UART_TX
#define TX_PIN                    8     // Connect to Modulo UART_RX

// The Modulo developer boards match the pinout of the Teensyduino 3.2 from www.pjrc.com
// You can connect the pins below to the same pins on the Modulo for easy connection,
// or you can put socket headers on the Teensy and the Modulo will plug right on top of the MCU
// (The Modulo has 8 extra pins that the Teensy doesn't, so it will overhang the MCU a bit)

#elif defined(TEENSYDUINO)            // Teensy 3.2 MCU from www.pjrc.com
#define RESET                     21    // This pin is used to reboot the Modulo when needed
// Only needed for SPI
#define INT_PIN                   14    // Modulo sends an interrupt on this pin to initiate communication
#define CS_PIN                    10    // Standard SPI chip select line
// Only needed for UART
#define RX_PIN                    7
#define TX_PIN                    8

#else
#error "Sorry, afLib can not identify this board, define necessary pins in sketch"
#endif

// Set a blink interval.
// We can send requests at a longer interval, of course, but we should try not to send
// requests faster than this interval so the ASR doesn't get overwhelmed.
#define BLINK_INTERVAL            2000  // 2 seconds

// define an afLib instance and a few booleans so we know the state of the connection to the Afero Cloud
af_lib_t* af_lib = NULL;
bool asrReady = false;          // If false, we're waiting on AF_MODULE_STATE_INITIALIZED, if true, we can communicate with ASR
bool asrRebootPending = false;  // If true, a reboot is needed, e.g. if we received an OTA firmware or profile update.
bool asrSyncPending = false;    // If true, we've just rebooted, so update the Modulo with our MCU attribute values

// variables to monitor and control blink state
volatile long lastBlink = 0;                   // Time of last blink
volatile bool blinking = false;                // Track whether LED is blinking; represented by attribute AF_BLINK
volatile bool moduloLEDState = false;          // Track whether the Modulo LED is on
uint16_t prevButtonValue = 0;                  // Track the button value...
uint16_t curButtonValue = prevButtonValue;     // ...so we know when it has changed

// Turn the Modulo LED off and on by setting the state of the ASR's GPIO0 pin.
void setModuloLED(bool state) {
    if (moduloLEDState != state) {
        int result = af_lib_set_attribute_16(af_lib, AF_MODULO_LED, state);
        if (result != AF_SUCCESS) {
            // A more robust app would retry or act on the specific error returned
            Serial.print("Set LED returned error: ");
            Serial.println(result);
        }
        moduloLEDState = state;
    }
}

// This callback is executed any time ASR has information for the MCU
// The name of this event is defined in the aflib initialization in setup()
void attrEventCallback(const af_lib_event_type_t eventType,
                       const af_lib_error_t error,
                       const uint16_t attributeId,
                       const uint16_t valueLen,
                       const uint8_t* value) {

    // Print out the attribute and its value
    printAttribute(attributeId, valueLen, value);

    switch (eventType) {
        case AF_LIB_EVENT_ASR_NOTIFICATION:
            // Unsolicited notification when a non-MCU attribute changes state
            switch (attributeId) {
                case AF_MODULO_LED:
                    // Update the state of the LED based on the actual attribute value.
                    moduloLEDState = (*value == 1);
                    break;

                case AF_MODULO_BUTTON:
                    // curButtonValue is checked in loop(). If changed, will toggle the blinking state there
                    curButtonValue = *(uint16_t*) value;
                    break;

                case AF_SYSTEM_ASR_STATE:
                    Serial.print("ASR state=");
                    switch (value[0]) {
                        case AF_MODULE_STATE_REBOOTED:
                            Serial.println("Rebooted");
                            asrReady = false;   // Rebooted, so we we can't talk to it yet
                            break;

                        case AF_MODULE_STATE_LINKED:
                            Serial.println("Linked");
// "Linked" is the final connected state returned by the Modulo-1
// all other devices will return an Initialized state below when connection is completed
#if AF_BOARD == AF_BOARD_MODULO_1
                            asrReady = true;
                            asrSyncPending = true;
#endif
                            break;

                        case AF_MODULE_STATE_UPDATING:
                            Serial.println("Updating");
                            break;

                        case AF_MODULE_STATE_UPDATE_READY:
                            Serial.println("Updated, need reboot");
                            asrRebootPending = true;
                            break;

                        case AF_MODULE_STATE_INITIALIZED:
                            Serial.println("Initialized");
                            asrReady = true;
                            asrSyncPending = true;
                            break;

                    }
                    break;

                default:
                    break;
            }
            break;

        case AF_LIB_EVENT_MCU_SET_REQUEST:
            // Request from ASR to MCU to set an MCU attribute, requires a call to af_lib_send_set_response()
            switch (attributeId) {
                case AF_BLINK:
                    // This MCU attribute controls whether we should be blinking.
                    blinking = (*value == 1);
                    // We just echo back what the ASR sent us, to let it know we were successful
                    // If we can't set this value, we'd return false below and value would be the "old"
                    // value that the update didn't affect
                    af_lib_send_set_response(af_lib, AF_BLINK, true, valueLen, value);
                    break;

                default:
                    break;
            }
            break;

        default:
            break;
    }


}

void setup() {

    Serial.begin(115200);

    while (!Serial && millis() < 3000) { // wait for serial port
        ;
    }

    Serial.println("Starting afBlink");
    // The Plinto board automatically connects reset on UNO to reset on Modulo
    // If we're using Teensy, we need to reset it manually.
#if defined(TEENSYDUINO)
    pinMode(RESET, OUTPUT);
    digitalWrite(RESET, 0);
    delay(250);
    digitalWrite(RESET, 1);
#endif

    /**
       Initialize the afLib - this depends on communications protocol used (SPI or UART)

        Configuration involves a few common items:
            af_transport_t - a transport implementation for a specific protocol (SPI or UART)
            attrEventCallback - the function to be called when ASR has data for MCU.
        And a few protocol-specific items:
            for SPI:
                INT_PIN - the pin used for SPI slave interrupt.
                arduinoSPI - class to handle SPI communications.
            for UART:
                RX_PIN, TX_PIN - pins used for receive, transmit.
                arduinoUART - class to handle UART communications.
    */

#if defined(ARDUINO_USE_UART)
    Serial.println("Using UART");
    af_transport_t *arduinoUART = arduino_transport_create_uart(RX_PIN, TX_PIN, UART_BAUD_RATE);
    af_lib = af_lib_create_with_unified_callback(attrEventCallback, arduinoUART);
#elif defined(ARDUINO_USE_SPI)
    Serial.println("Using SPI");
    af_transport_t* arduinoSPI = arduino_transport_create_spi(CS_PIN);
    af_lib = af_lib_create_with_unified_callback(attrEventCallback, arduinoSPI);
    arduino_spi_setup_interrupts(af_lib, digitalPinToInterrupt(INT_PIN));
#else
#error "Please define a a communication transport (ie SPI or UART)."
#endif
}

void loop() {
    // ALWAYS give the afLib state machine time to do its work - avoid blind delay() calls
    // of any length, instead repeat calls to af_lib_loop() while waiting for whatever it is
    // you're waiting to happen. Some afLib operations take multiple loop() calls to complete.
    af_lib_loop(af_lib);

    // Until the ASR is initialized, we shouldn't talk to it, if it's not ready we just exit loop() altogether.
    if (!asrReady) return;
    
    // asrReady == true from here on down
    // If we were asked to reboot (e.g. after an OTA firmware update), do it now.
    if (asrRebootPending) {
        int retVal = af_lib_set_attribute_32(af_lib, AF_SYSTEM_COMMAND, AF_MODULE_COMMAND_REBOOT);
        // If retVal returns an error, leave asrRebootPending set to try it again next time around
        asrRebootPending = (retVal != AF_SUCCESS);
        // if retVal returned success, then we wait for the ASR reboot to happen
        if (!asrRebootPending) {
            asrReady = false;
        }
    }

    // After ASR is initialized, we need to send it the values of all of our MCU attributes (we only have 1 in this app)
    // "blinking" defautls to false at MCU boot, but it may not be false if the ASR reboots and we stay running
    if (asrSyncPending) {
        if (af_lib_set_attribute_bool(af_lib, AF_BLINK, blinking) == AF_SUCCESS) {
            asrSyncPending = false;
        }
    }

    // If the Modulo button was pressed (in attrEventHandler), toggle 'blinking'
    if (prevButtonValue != curButtonValue) {
        if (af_lib_set_attribute_bool(af_lib, AF_BLINK, !blinking) == AF_SUCCESS) {
            if (!blinking) setModuloLED(false);
            blinking = !blinking;
            prevButtonValue = curButtonValue;
        }
    }

    // Flash the LED whenever the 'blinking' value is true
    if (blinking) {
        if (millis() - lastBlink > BLINK_INTERVAL) {
            setModuloLED(!moduloLEDState);
            lastBlink = millis();
        }
    }
}

// Debugging Stuff

// Arduino Uno boards have inadequate memory to tolerate pretty-printing debug methods
// so these are pretty basic just to show program flow.
#define ATTR_PRINT_BUFFER_LEN     40

char attr_print_buffer[ATTR_PRINT_BUFFER_LEN];

void getPrintAttrHeader(const char* attrLabel, const uint16_t attributeId,
                        const uint16_t valueLen) {
    memset(attr_print_buffer, 0, ATTR_PRINT_BUFFER_LEN);
    snprintf(attr_print_buffer, ATTR_PRINT_BUFFER_LEN, "attr %s=", attrLabel);
}

void
printAttrBool(const char* attrLabel, const uint16_t attributeId, const uint16_t valueLen,
              const uint8_t* value) {
    getPrintAttrHeader(attrLabel, attributeId, valueLen);
    if (valueLen > 0) {
        strcat(attr_print_buffer, *value == 1 ? "true" : "false");
    }
    Serial.println(attr_print_buffer);
}

void
printAttr16(const char* attrLabel, const uint16_t attributeId, const uint16_t valueLen,
            const uint8_t* value) {
    getPrintAttrHeader(attrLabel, attributeId, valueLen);
    if (valueLen > 0) {
        char intStr[6];
        strcat(attr_print_buffer, itoa(*((int16_t*) value), intStr, 10));
    }
    Serial.println(attr_print_buffer);
}

void
printAttrStr(const char* attrLabel, const uint16_t attributeId, const uint16_t valueLen,
             const uint8_t* value) {
    getPrintAttrHeader(attrLabel, attributeId, valueLen);
    int len = strlen(attr_print_buffer);
    for (int i = 0; i < valueLen; i++) {
        attr_print_buffer[len + i] = (char) value[i];
    }
    Serial.println(attr_print_buffer);
}

void printAttribute(const uint16_t attributeId, const uint16_t valueLen, const uint8_t* value) {
    switch (attributeId) {
        case AF_BLINK:
            printAttrBool("BLINK", attributeId, valueLen, value);
            break;

        case AF_MODULO_LED:
            printAttr16("Modulo LED", attributeId, valueLen, value);
            break;

        case AF_MODULO_BUTTON:
            printAttr16("Modulo Button", attributeId, valueLen, value);
            break;

        case AF_APPLICATION_VERSION:
            printAttr16("FW Version", attributeId, valueLen, value);
            break;

        case AF_PROFILE_VERSION:
            printAttr16("Profile Version", attributeId, valueLen, value);
            break;

        case AF_SYSTEM_REBOOT_REASON:
            // This attribute can be very long, but the first few characters are all we 
            // generally care about - the Uno is very short on RAM so we don't waste it
            // and we only dump the first few characters
            printAttrStr("Reboot Reason", attributeId, 9, value);
            break;
    }
}
